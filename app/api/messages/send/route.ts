import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { conversationId, agentId, content, userId } = body;

    // Validate input
    if (!agentId || !content || !userId) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Create or get conversation
    let conversation;
    if (conversationId) {
      conversation = await prisma.conversation.findUnique({
        where: { id: conversationId }
      });
    }

    if (!conversation) {
      // Create new conversation
      conversation = await prisma.conversation.create({
        data: {
          userId,
          agentId,
          title: `Chat with ${agentId}`,
          messages: [],
          lastMessageAt: new Date()
        }
      });
    }

    // Get existing messages
    const existingMessages = (conversation.messages as any[]) || [];

    // Create user message
    const userMessage = {
      id: `msg_${Date.now()}_user`,
      role: 'user',
      content,
      timestamp: new Date().toISOString(),
      status: 'sent'
    };

    // Add user message to conversation
    existingMessages.push(userMessage);

    // Simulate AI response (in production, this would call the AI service)
    const agentMessage = {
      id: `msg_${Date.now()}_agent`,
      role: 'agent',
      content: `This is a simulated response from ${agentId}. In production, this would be generated by the AI service.`,
      timestamp: new Date().toISOString(),
      agentId,
      metadata: {
        confidence: 0.95,
        suggestions: ['Try asking about...', 'You might also want to...']
      }
    };

    // Add agent message after a delay (simulating processing)
    setTimeout(async () => {
      existingMessages.push(agentMessage);
      
      await prisma.conversation.update({
        where: { id: conversation.id },
        data: {
          messages: existingMessages,
          lastMessageAt: new Date()
        }
      });
    }, 1500);

    // Update conversation with user message
    const updatedConversation = await prisma.conversation.update({
      where: { id: conversation.id },
      data: {
        messages: existingMessages,
        lastMessageAt: new Date()
      }
    });

    return NextResponse.json({
      success: true,
      conversationId: conversation.id,
      message: userMessage,
      agentMessage: agentMessage // In production, this would be sent via WebSocket
    });
  } catch (error) {
    console.error('Error sending message:', error);
    return NextResponse.json(
      { error: 'Failed to send message' },
      { status: 500 }
    );
  }
}

export const dynamic = 'force-dynamic';
